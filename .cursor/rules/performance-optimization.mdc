# 性能优化规则

## 代码层面优化

### Vue 组件优化

```vue
<template>
  <!-- 使用 v-show 而不是 v-if 对于频繁切换的元素 -->
  <view v-show="isVisible" class="frequent-toggle">
    <!-- 内容 -->
  </view>

  <!-- 长列表使用虚拟滚动 -->
  <recycle-list :items="longList" item-key="id">
    <template #default="{ item }">
      <view>{{ item.name }}</view>
    </template>
  </recycle-list>

  <!-- 图片懒加载 -->
  <image :src="imageSrc" lazy-load @load="onImageLoad" @error="onImageError" />
</template>

<script setup lang="ts">
// 使用 shallowRef 对于大型不可变数据
const largeData = shallowRef(bigDataObject)

// 使用 computed 缓存计算结果
const expensiveValue = computed(() => {
  return heavyCalculation(props.data)
})

// 防抖处理用户输入
const debouncedSearch = debounce((query: string) => {
  searchApi(query)
}, 300)

// 组件卸载时清理定时器
onUnmounted(() => {
  clearInterval(timer)
  clearTimeout(timeout)
})
</script>
```

### 状态管理优化

```typescript
// Pinia store 优化
export const useOptimizedStore = defineStore('optimized', () => {
  // 使用 shallowRef 减少深度响应
  const data = shallowRef<LargeObject[]>([])

  // 计算属性缓存
  const filteredData = computed(() => {
    return data.value.filter((item) => item.isActive)
  })

  // 批量更新
  const batchUpdate = (updates: Partial<LargeObject>[]) => {
    // 暂停响应性追踪
    const currentData = toRaw(data.value)
    const newData = currentData.map((item) => {
      const update = updates.find((u) => u.id === item.id)
      return update ? { ...item, ...update } : item
    })
    data.value = newData
  }

  // 分页加载
  const pageSize = 20
  const currentPage = ref(1)

  const loadMore = async () => {
    const newItems = await fetchData({
      page: currentPage.value,
      size: pageSize,
    })
    data.value.push(...newItems)
    currentPage.value++
  }

  return {
    data: readonly(data),
    filteredData,
    batchUpdate,
    loadMore,
  }
})
```

## 网络请求优化

### 请求缓存策略

```typescript
// 请求缓存实现
class RequestCache {
  private cache = new Map<string, { data: any; timestamp: number }>()
  private readonly CACHE_DURATION = 5 * 60 * 1000 // 5分钟

  get(key: string) {
    const cached = this.cache.get(key)
    if (cached && Date.now() - cached.timestamp < this.CACHE_DURATION) {
      return cached.data
    }
    this.cache.delete(key)
    return null
  }

  set(key: string, data: any) {
    this.cache.set(key, { data, timestamp: Date.now() })
  }

  clear() {
    this.cache.clear()
  }
}

// 使用示例
const cache = new RequestCache()

export const cachedHttp = async <T>(options: CustomRequestOptions): Promise<T> => {
  const cacheKey = `${options.method}-${options.url}-${JSON.stringify(options.data || options.query)}`

  // 只缓存 GET 请求
  if (options.method === 'GET') {
    const cached = cache.get(cacheKey)
    if (cached) {
      return cached
    }
  }

  const result = await http<T>(options)

  if (options.method === 'GET') {
    cache.set(cacheKey, result)
  }

  return result
}
```

### 请求合并和并发控制

```typescript
// 请求合并
class RequestBatcher {
  private batches = new Map<string, any[]>()
  private timers = new Map<string, NodeJS.Timeout>()

  batch<T>(key: string, request: () => Promise<T>, delay = 50): Promise<T> {
    return new Promise((resolve, reject) => {
      if (!this.batches.has(key)) {
        this.batches.set(key, [])
      }

      this.batches.get(key)!.push({ request, resolve, reject })

      if (this.timers.has(key)) {
        clearTimeout(this.timers.get(key)!)
      }

      this.timers.set(
        key,
        setTimeout(() => {
          this.executeBatch(key)
        }, delay),
      )
    })
  }

  private async executeBatch(key: string) {
    const batch = this.batches.get(key) || []
    this.batches.delete(key)
    this.timers.delete(key)

    // 并发执行所有请求
    const results = await Promise.allSettled(batch.map((item) => item.request()))

    results.forEach((result, index) => {
      if (result.status === 'fulfilled') {
        batch[index].resolve(result.value)
      } else {
        batch[index].reject(result.reason)
      }
    })
  }
}

// 并发控制
class ConcurrencyController {
  private running = 0
  private queue: (() => void)[] = []

  constructor(private maxConcurrency = 6) {}

  async execute<T>(task: () => Promise<T>): Promise<T> {
    return new Promise((resolve, reject) => {
      const run = async () => {
        this.running++
        try {
          const result = await task()
          resolve(result)
        } catch (error) {
          reject(error)
        } finally {
          this.running--
          this.processQueue()
        }
      }

      if (this.running < this.maxConcurrency) {
        run()
      } else {
        this.queue.push(run)
      }
    })
  }

  private processQueue() {
    if (this.queue.length > 0 && this.running < this.maxConcurrency) {
      const next = this.queue.shift()!
      next()
    }
  }
}
```

## 资源优化

### 图片优化

```vue
<template>
  <!-- 图片懒加载和压缩 -->
  <image
    :src="optimizedImageSrc"
    :webp="supportsWebP"
    lazy-load
    mode="aspectFill"
    @load="onImageLoad"
    @error="onImageError"
  />
</template>

<script setup lang="ts">
// 图片格式优化
const supportsWebP = computed(() => {
  // #ifdef H5
  const canvas = document.createElement('canvas')
  return canvas.toDataURL('image/webp').indexOf('webp') > -1
  // #endif

  // #ifndef H5
  return false
  // #endif
})

// 根据设备像素比选择合适的图片
const optimizedImageSrc = computed(() => {
  const dpr = uni.getSystemInfoSync().pixelRatio
  const size = dpr > 2 ? '@2x' : '@1x'
  return `${props.src}${size}.${supportsWebP.value ? 'webp' : 'jpg'}`
})

// 图片预加载
const preloadImages = (urls: string[]) => {
  urls.forEach(url => {
    // #ifdef H5
    const img = new Image()
    img.src = url
    // #endif

    // #ifdef MP || APP-PLUS
    uni.getImageInfo({ src: url })
    // #endif
  })
}
```

### 代码分割和懒加载

```typescript
// 路由懒加载
const routes = [
  {
    path: '/heavy-page',
    component: () => import('@/pages/heavy-page/index.vue'),
  },
]

// 组件懒加载
const HeavyComponent = defineAsyncComponent({
  loader: () => import('@/components/HeavyComponent.vue'),
  loadingComponent: LoadingComponent,
  errorComponent: ErrorComponent,
  delay: 200,
  timeout: 3000,
})

// 动态导入工具库
const loadLodash = async () => {
  const { default: _ } = await import('lodash-es')
  return _
}
```

## 渲染优化

### 虚拟滚动实现

```vue
<template>
  <scroll-view :scroll-y="true" :style="{ height: containerHeight + 'px' }" @scroll="onScroll">
    <view :style="{ height: totalHeight + 'px', position: 'relative' }">
      <view
        v-for="item in visibleItems"
        :key="item.id"
        :style="{
          position: 'absolute',
          top: item.top + 'px',
          height: itemHeight + 'px',
          width: '100%',
        }"
      >
        <slot :item="item.data" />
      </view>
    </view>
  </scroll-view>
</template>

<script setup lang="ts">
interface Props {
  items: any[]
  itemHeight: number
  containerHeight: number
}

const props = defineProps<Props>()

const scrollTop = ref(0)
const visibleCount = computed(() => Math.ceil(props.containerHeight / props.itemHeight) + 2)

const startIndex = computed(() => Math.max(0, Math.floor(scrollTop.value / props.itemHeight) - 1))

const endIndex = computed(() => Math.min(props.items.length, startIndex.value + visibleCount.value))

const visibleItems = computed(() => {
  return props.items.slice(startIndex.value, endIndex.value).map((item, index) => ({
    id: item.id,
    data: item,
    top: (startIndex.value + index) * props.itemHeight,
  }))
})

const totalHeight = computed(() => props.items.length * props.itemHeight)

const onScroll = (e: any) => {
  scrollTop.value = e.detail.scrollTop
}
</script>
```

### 防抖和节流

```typescript
// 防抖函数
export function debounce<T extends (...args: any[]) => any>(
  func: T,
  wait: number,
): (...args: Parameters<T>) => void {
  let timeout: NodeJS.Timeout

  return function executedFunction(...args: Parameters<T>) {
    const later = () => {
      clearTimeout(timeout)
      func(...args)
    }

    clearTimeout(timeout)
    timeout = setTimeout(later, wait)
  }
}

// 节流函数
export function throttle<T extends (...args: any[]) => any>(
  func: T,
  limit: number,
): (...args: Parameters<T>) => void {
  let inThrottle: boolean

  return function executedFunction(...args: Parameters<T>) {
    if (!inThrottle) {
      func(...args)
      inThrottle = true
      setTimeout(() => (inThrottle = false), limit)
    }
  }
}

// 使用示例
const debouncedSearch = debounce((query: string) => {
  searchAPI(query)
}, 300)

const throttledScroll = throttle((scrollTop: number) => {
  updateScrollPosition(scrollTop)
}, 16) // 60fps
```

## 内存管理

### 内存泄漏防护

```typescript
// 组件内存清理
export default defineComponent({
  setup() {
    const timers: NodeJS.Timeout[] = []
    const observers: IntersectionObserver[] = []

    // 添加定时器时记录
    const addTimer = (callback: () => void, delay: number) => {
      const timer = setTimeout(callback, delay)
      timers.push(timer)
      return timer
    }

    // 添加观察器时记录
    const addObserver = (callback: IntersectionObserverCallback) => {
      // #ifdef H5
      const observer = new IntersectionObserver(callback)
      observers.push(observer)
      return observer
      // #endif

      // #ifndef H5
      return null
      // #endif
    }

    // 组件卸载时清理
    onUnmounted(() => {
      timers.forEach((timer) => clearTimeout(timer))
      timers.length = 0

      observers.forEach((observer) => observer.disconnect())
      observers.length = 0
    })

    return {
      addTimer,
      addObserver,
    }
  },
})
```

## 构建优化

### Bundle 分析和优化

```typescript
// vite.config.ts
export default defineConfig({
  build: {
    rollupOptions: {
      output: {
        // 手动分包
        manualChunks: {
          vendor: ['vue', 'pinia'],
          ui: ['@dcloudio/uni-ui', '@climblee/uv-ui'],
          charts: ['echarts'],
          utils: ['lodash-es', 'dayjs'],
        },
      },
    },
  },

  plugins: [
    // 打包分析
    visualizer({
      filename: 'dist/stats.html',
      open: true,
      gzipSize: true,
    }),
  ],
})
```

## 监控和测量

### 性能指标收集

```typescript
// 性能监控工具
class PerformanceMonitor {
  private metrics = new Map<string, number[]>()

  mark(name: string) {
    performance.mark(name)
  }

  measure(name: string, startMark: string, endMark?: string) {
    const measurement = performance.measure(name, startMark, endMark)

    if (!this.metrics.has(name)) {
      this.metrics.set(name, [])
    }

    this.metrics.get(name)!.push(measurement.duration)

    // 清理旧的 marks
    performance.clearMarks(startMark)
    if (endMark) performance.clearMarks(endMark)
    performance.clearMeasures(name)

    return measurement.duration
  }

  getAverageTime(name: string): number {
    const times = this.metrics.get(name) || []
    return times.reduce((sum, time) => sum + time, 0) / times.length
  }

  report() {
    const report: Record<string, number> = {}
    this.metrics.forEach((times, name) => {
      report[name] = this.getAverageTime(name)
    })
    return report
  }
}

// 使用示例
const monitor = new PerformanceMonitor()

// 测量页面加载时间
monitor.mark('page-start')
onMounted(() => {
  monitor.mark('page-end')
  const loadTime = monitor.measure('page-load', 'page-start', 'page-end')
  console.log('页面加载时间:', loadTime, 'ms')
})
```

description:
globs:
alwaysApply: false

---
